<!DOCTYPE html>
<html>
<head>
	<meta charset='utf-8'>
	<title>Piplock</title>
	<style>
        :root {
            /* --color-hud: #33f0ff; */
            --color-hud: #ff9911;
            --color-success: #77ff46;
            --color-fail: #dd1e28;
            /* --filter-glow-hud: drop-shadow(0 0 2px #00aadd) drop-shadow(0 0 100px #000000); */
            --filter-glow-hud: drop-shadow(0 0 2px #aa8811) drop-shadow(0 0 100px #000000);
            --filter-glow-success: drop-shadow(0 0 2px #55dd22) drop-shadow(0 0 100px #000000);
            --filter-glow-fail: drop-shadow(0 0 2px #990811) drop-shadow(0 0 100px #000000);
            --filter-frame-glow-hud: drop-shadow(0 0 4px #aa8811);

            --difficulty-open-height: 8em;
            --difficulty-closed-height: 4em;
        }

        * {
            color: var(--color-hud);
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Consolas, Courier, monospace;
            /* font-weight: bold; */
            white-space: pre;
        }

        body {
            background-color: #111118;
            min-height: 500px;
        }

        .flex-row {
            display: flex;
            flex-direction: row;
        }
        .flex-col {
            display: flex;
            flex-direction: column;
        }
        .bordered-widget {
            background-color: #33333308;
            filter: var(--filter-glow-hud);
            overflow: hidden;
            padding: 1em;
        }

        #background { /* fixed-pos blurred bg image */
            background-image: url('source/DALLE\ -\ Blue\ Flow.webp'); /* generated by DALLE */
            background-attachment: fixed;
            background-position: center;
            background-repeat: no-repeat;
            background-size: cover;
            filter: blur(8px);
            -webkit-filter: blur(8px);
            opacity: 0.4;
            display: block;
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }
        #background:after { /* vignette filter on bg img */
            content: "";
            display: block;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #11111800 0%,#111118bb 70%,#111118ff 100%);
            /* border-radius: 50%; */
            position: absolute;
            top: 0; left: 0;
        }

        .frame-top, .frame-bot {
            border: 1px solid var(--color-hud);
            filter: var(--filter-frame-glow-hud);
            display: inline-block;
            position: absolute;
            height: 1.25em;
            width: 100%;
            left: 0;
        }
        .frame-top {
            border-bottom: none;
            top: 0;
        }
        .frame-bot {
            border-top: none;
            bottom: 0;
        }
        .frame-left, .frame-right {
            border: 1px solid var(--color-hud);
            filter: var(--filter-frame-glow-hud);
            display: inline-block;
            position: absolute;
            height: 100%;
            width: 1.25em;
            top: 0;
        }
        .frame-left {
            border-right: none;
            left: 0;
        }
        .frame-right {
            border-left: none;
            right: 0;
        }

        .centered-label {
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 1em;
            
            width: 100%;
        }
        .centered-sublabel {
            /* font-size: 1.5rem; */
            text-align: center;
            margin-bottom: 0.5em;
            
            width: 100%;
        }

        /* LOCK VISUALIZER (CENTER FOCUS) */
        #lock-box {
            border: 8px double var(--color-hud);
            border-radius: 50%;
            filter: var(--filter-glow-hud);
            display: inline-block;
            position: absolute;
            height: 32rem;
            width: 32rem;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
        }

        /* CONSOLE WIDGET (TOP-LEFT) */
        #log {
            position: absolute;
            top: 1vmax;
            left: 1vmax;
        }

        /* CONTROLS WIDGET (BOTTOM-LEFT) */
        #controls-widget {
            filter: var(--filter-glow-hud);
            position: absolute;
            bottom: 2em;
            left: 2em;
            gap: 0.5em;
        }
        .controls-key, .controls-spacebar {
            cursor: pointer;
            border: 2px solid var(--color-hud);
            border-radius: 0.5em;
            display: inline-block;
            font-size: 1.5em;
            text-align: center;
            align-self: center;
        }
        .controls-key {
            width: 2em;
            height: 2em;
        }
        .controls-spacebar {
            width: 5em;
            height: 2em;
        }

    </style>
</head>
<body>

    <div id='background'></div>
    <div id='log' class='bordered-widget'>
        <div class='frame-top'></div>
        <div class='frame-bot'></div>
    </div>
    <div id='lock-box'>[content]</div>

    <div id='controls-widget' class='flex-col'> <!-- element is only 50% as bright if not positioned, for some reason -->
        <div id='controls-up' class='controls-key' onclick='tryGuess(2)'>W</div>
        <div class='flex-row' style='justify-content:center; gap:0.5em;'>
            <div id='controls-left' class='controls-key' onclick='tryGuess(0)'>A</div>
            <div id='controls-down' class='controls-key' onclick='tryGuess(3)'>S</div>
            <div id='controls-right' class='controls-key' onclick='tryGuess(1)'>D</div>
        </div>
    </div>

    <script type='text/javascript'>

        //// DOM ////

        const msgLog = document.getElementById('log');
        const lockBox = document.getElementById('lock-box');
        // controls vis
        const controlsUp = document.getElementById('controls-up');
        const controlsLeft = document.getElementById('controls-left');
        const controlsDown = document.getElementById('controls-down');
        const controlsRight = document.getElementById('controls-right');

        const MSG_INSTRUCTIONS = [
            'CONTROLS',
            '',
            '[w][a][d] to triangulate',
            '[s] to reset to starting position',
            '(arrow keys also work)',
            '',
            '[n] to gen new pip-lock with current settings'

        ].join('\n');
        msgLog.innerHTML = MSG_INSTRUCTIONS + `<div class = 'frame-top'></div><div class = 'frame-bot'></div>`;

        const CSSVars = {
            get : (k) => getComputedStyle(document.documentElement).getPropertyValue(k),
            set : (k,v) => document.documentElement.style.setProperty(k,v)
        };
        const randI = (min,max) => Math.floor(Math.random() * (max - min + 1)) + min;
        const randInt = (min,max) => {
            if (min > max) [min,max] = [max,min];
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

       
        function advance () {
            console.log(`Sweet spot is ${lock.dist.toFixed(1)} away...`);
        }
        function succeed () {
            console.log(`Congrats, you picked the lock in ${lock.moves} moves!`);
        }
        
        //
        
        const REGEX_VALID_GAMESTATE = /^([0-4](?:\.5)?)-([0-4](?:\.5)?)-([0-4](?:\.5)?)$/;
        function isValidGamestate (gamestate) {
            const [l,u,r] = gamestate.map(x => parseFloat(x));
            if (l+u+r != 6) return false; // always 6 pips total
            if (l > 4 || u > 4 || r > 4) return false; // pip-stack has between 0 and 4 pips
            if (l < 0 || u < 0 || r < 0) return false;
            if ((l*10)%5 != 0 || (u*10)%5 != 0 || (r*10)%5 != 0) return false; // pips are all increments of .5
            return true;
        }
        // console.log( isValidGamestate('2-2-2') ); // true ([init])
        // console.log( isValidGamestate('4-2-0') ); // true (LLUL)
        // console.log( isValidGamestate('0-3-3') ); // true (RURU)
        // console.log( isValidGamestate('3-1.5-1.5') ); // true (L)
        // console.log( isValidGamestate('5-1-0') ); // false, pipstack too tall
        // console.log( isValidGamestate('-2-4-4') ); // false, negative pipstack / blank pip
        // console.log( isValidGamestate('3-2-2') ); // false, too many pips
        // console.log( isValidGamestate('3-2') ); // false, too few pipstacks
        // console.log( isValidGamestate('3-1.75-1.25') ); // false, bad increment

        
        const MOVE_DIR_RESET = 0;
        const MOVE_DIR_LEFT = 1;
        const MOVE_DIR_UP = 2;
        const MOVE_DIR_RIGHT = 3;
        function newGamestate (start,dir) {
            const [l,u,r] = start.map(x => parseFloat(x));
            // console.log(l,u,r);
            if (dir == MOVE_DIR_LEFT) {
                if (l == 4) return [l,u,r]; // left corner full (420,402,411) can't draw more pips
                if (l == 3.5) { // draw single half-pip from lowest non-zero pipstack
                    if (u == 0) return [l+0.5,u,r-0.5];
                    if (r == 0) return [l+0.5,u-0.5,r];
                    return (u < r) ? [l+0.5,u-0.5,r] : [l+0.5,u,r-0.5];
                } else { // draw two half-pips, one from each pipstack if possible
                    if (u == 0) return [l+1,u,r-1]; // if up is empty, pull both half-pips from right
                    if (r == 0) return [l+1,u-1,r]; // if right is empty, pull both half-pips from up
                    return [l+1,u-0.5,r-0.5]; // pull half-pips normally
                }
            } else if (dir == MOVE_DIR_UP) {
                if (u == 4) return [l,u,r]; // upper corner (240,042,141) can't move up
                if (u == 3.5) { // draw single half-pip from lowest non-zero pipstack
                    if (l == 0) return [l,u+0.5,r-0.5];
                    if (r == 0) return [l-0.5,u+0.5,r];
                    return (l < r) ? [l-0.5,u+0.5,r] : [l,u+0.5,r-0.5];
                } else { // draw two half-pips, one from each pipstack if possible
                    if (l == 0) return [l,u+1,r-1]; // if left is empty, pull both half-pips from right
                    if (r == 0) return [l-1,u+1,r]; // if right is empty, pull both half-pips from left
                    return [l-0.5,u+1,r-0.5]; // pull half-pips normally
                }
            } else if (dir == MOVE_DIR_RIGHT) {
                if (r == 4) return [l,u,r]; // right corner (204,024,114) can't move right
                if (r == 3.5) { // draw single half-pip from lowest non-zero pipstack
                    if (l == 0) return [l,u-0.5,r+0.5];
                    if (u == 0) return [l-0.5,u,r+0.5];
                    return (l < u) ? [l-0.5,u,r+0.5] : [l,u-0.5,r+0.5];
                } else { // draw two half-pips, one from each pipstack if possible
                    if (l == 0) return [l,u-1,r+1]; // if left is empty, pull both half-pips from up
                    if (u == 0) return [l-1,u,r+1]; // if up is empty, pull both half-pips from left
                    return [l-0.5,u-0.5,r+1]; // pull half-pips normally
                }
            } else if (dir == MOVE_DIR_RESET) {
                return [2,2,2];
            } else {
                console.warn(`ERR Invalid move direction "${dir}"`);
            }
        }
        // console.log( newGamestate([2,2,2],MOVE_DIR_LEFT) );
        // console.log( newGamestate([2,2,2],MOVE_DIR_UP) );
        // console.log( newGamestate([2,2,2],MOVE_DIR_RIGHT) );
        // console.log( newGamestate([4,2,0],MOVE_DIR_LEFT) );

        

        class PiplockSolver {
            constructor () {
                this.initialState = '2-2-2';
                this.gamestates = {};
                // this.transitions = {}; // is there any point mapping this since they're cheap to calc?
            }
            map () {
                const MOVE_CHARS = ['-','L','U','R']; // reset,left,up,right
                function equivalentStates (s0,s1) {
                    const [state0,len0,path0] = s0;
                    const [l0,u0,r0] = state0;
                    const [state1,len1,path1] = s1;
                    const [l1,u1,r1] = state1;
                    return (l0 != l1 || u0 != u1 || r0 != r1);
                }
                // BFS
                let overflowProt = 1000;
                let queue = [ [[2,2,2], 0, '', '2-2-2'] ]; // [gamestate, pathlen, inputs, path]
                while (queue.length > 0 && overflowProt > 0) {
                    overflowProt--;
                    const [currState,currLen,currInputs,currPath] = queue.shift();
                    for (let dir of [MOVE_DIR_LEFT,MOVE_DIR_UP,MOVE_DIR_RIGHT]) {
                        const nextState = newGamestate(currState,dir);
                        const nextLen = currLen + 1;
                        const nextInputs = currInputs + MOVE_CHARS[dir];
                        const nextStr = nextState.join('-');
                        const nextPath = currPath + '=>' + nextStr;

                        // if (!isValidGamestate(nextState)) {
                        //     console.error(`ERR ${nextStr} by ${dir} from ${nextPath} (len ${nextLen})`);
                        // } else

                        if (!this.gamestates[nextStr]) { // if unvisited, auto pass
                            if (!isValidGamestate(nextState)) {
                                console.error(`ERR ${nextStr} by ${MOVE_CHARS[dir]} from ${nextPath} (len ${nextLen})`);
                                continue;
                            } else {
                                console.log(`FIRST ${nextStr} by ${MOVE_CHARS[dir]} from ${nextPath} (len ${nextLen})`);
                            }
                            this.gamestates[nextStr] = [nextState,nextLen,nextInputs,nextPath];
                            queue.push([nextState,nextLen,nextInputs,nextPath]);
                        } else if (nextLen < this.gamestates[nextStr][1]) { // if shorter than previous optimum, replace it
                            console.debug(`REPLACE ${nextStr} by ${MOVE_CHARS[dir]} from ${this.gamestates[nextStr][2]} to ${nextPath} (len ${this.gamestates[nextStr][1]} to ${nextLen})`);
                            this.gamestates[nextStr] = [nextState,nextLen,nextInputs,nextPath];
                            queue.push([nextState,nextLen,nextInputs,nextPath]);
                        } else {
                            console.warn(`FAIL ${nextStr} by ${MOVE_CHARS[dir]} from ${nextPath} (len ${nextLen})`);
                        }
                    }
                }
                if (overflowProt <= 0) {
                    console.warn(`WARN Triggered loop overflow protection; loop may be infinite.`);
                    console.log(queue);
                }
                console.log(this.gamestates);
            }
            minMovesTo (end) {
                const start = [2,2,2];
            }
            shortestPathTo (end) {
                const start = [2,2,2];
            }
        }

        let solver = new PiplockSolver();
        solver.map();


        let gamestate = [2,2,2];


        let dbgToggle = true;
        window.addEventListener('keydown', e => {
            // console.log(e.key);
            switch (e.key) {
            // controls
            case 'a':
            case 'ArrowLeft':  gamestate = newGamestate(gamestate,MOVE_DIR_LEFT);  console.log(gamestate); controlsLeft.style.borderWidth = '4px'; break;
            case 'd':
            case 'ArrowRight': gamestate = newGamestate(gamestate,MOVE_DIR_RIGHT); console.log(gamestate); controlsRight.style.borderWidth = '4px'; break;
            case 'w':
            case 'ArrowUp':    gamestate = newGamestate(gamestate,MOVE_DIR_UP);    console.log(gamestate); controlsUp.style.borderWidth = '4px'; break;
            case 's':
            case 'ArrowDown':  gamestate = newGamestate(gamestate,MOVE_DIR_RESET); console.log(gamestate); controlsDown.style.borderWidth = '4px'; break;
            // debug
            case '`':
                console.log('DEV KEY');
                break;
            }
        });
        window.addEventListener('keyup', e => {
            switch (e.key) {
            // controls
            case 'a':
            case 'ArrowLeft':  controlsLeft.style.borderWidth = '2px'; break;
            case 'd':
            case 'ArrowRight': controlsRight.style.borderWidth = '2px'; break;
            case 'w':
            case 'ArrowUp':    controlsUp.style.borderWidth = '2px'; break;
            case 's':
            case 'ArrowDown':  controlsDown.style.borderWidth = '2px'; break;
            }
        });

        // init
        console.log(MSG_INSTRUCTIONS);

    </script>

</body>