<!DOCTYPE html>
<html>
<head>
	<meta charset='utf-8'>
	<title>Piplock</title>
	<style>
        :root {
            /* --color-hud: #33f0ff; */
            --color-hud: #ff9911;
            --color-success: #77ff46;
            --color-fail: #dd1e28;
            /* --filter-glow-hud: drop-shadow(0 0 2px #00aadd) drop-shadow(0 0 100px #000000); */
            --filter-glow-hud: drop-shadow(0 0 2px #aa8811) drop-shadow(0 0 100px #000000);
            --filter-glow-success: drop-shadow(0 0 2px #55dd22) drop-shadow(0 0 100px #000000);
            --filter-glow-fail: drop-shadow(0 0 2px #990811) drop-shadow(0 0 100px #000000);
            --filter-frame-glow-hud: drop-shadow(0 0 4px #aa8811);

            --difficulty-open-height: 8em;
            --difficulty-closed-height: 4em;
        }

        * {
            color: var(--color-hud);
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Consolas, Courier, monospace;
            /* font-weight: bold; */
            white-space: pre;
        }

        body {
            background-color: #111118;
            min-height: 500px;
        }

        .flex-row {
            display: flex;
            flex-direction: row;
        }
        .flex-col {
            display: flex;
            flex-direction: column;
        }
        .bordered-widget {
            background-color: #33333308;
            filter: var(--filter-glow-hud);
            overflow: hidden;
            padding: 1em;
        }

        #background { /* fixed-pos blurred bg image */
            background-image: url('source/DALLE\ -\ Blue\ Flow.webp'); /* generated by DALLE */
            background-attachment: fixed;
            background-position: center;
            background-repeat: no-repeat;
            background-size: cover;
            filter: blur(8px);
            -webkit-filter: blur(8px);
            opacity: 0.4;
            display: block;
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }
        #background:after { /* vignette filter on bg img */
            content: "";
            display: block;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #11111800 0%,#111118bb 70%,#111118ff 100%);
            /* border-radius: 50%; */
            position: absolute;
            top: 0; left: 0;
        }

        .frame-top, .frame-bot {
            border: 1px solid var(--color-hud);
            filter: var(--filter-frame-glow-hud);
            display: inline-block;
            position: absolute;
            height: 1.25em;
            width: 100%;
            left: 0;
        }
        .frame-top {
            border-bottom: none;
            top: 0;
        }
        .frame-bot {
            border-top: none;
            bottom: 0;
        }
        .frame-left, .frame-right {
            border: 1px solid var(--color-hud);
            filter: var(--filter-frame-glow-hud);
            display: inline-block;
            position: absolute;
            height: 100%;
            width: 1.25em;
            top: 0;
        }
        .frame-left {
            border-right: none;
            left: 0;
        }
        .frame-right {
            border-left: none;
            right: 0;
        }

        .centered-label {
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 1em;
            
            width: 100%;
        }
        .centered-sublabel {
            /* font-size: 1.5rem; */
            text-align: center;
            margin-bottom: 0.5em;
            
            width: 100%;
        }

        /* LOCK VISUALIZER (CENTER FOCUS) */
        #lock-box {
            border: 8px double var(--color-hud);
            border-radius: 50%;
            filter: var(--filter-glow-hud);
            display: inline-block;
            position: absolute;
            height: 32rem;
            width: 32rem;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
        }
        .pipstack-large {
            --pip-width: 4em;
            --pip-height: 1em;
            /* background-image: linear-gradient(to right, var(--color-hud) 40%, #fff0 20%); /* horizontal version */
            background-image: linear-gradient(to top, var(--color-hud) 80%, #fff0 20%); /* alternate bands of color and transparency */
            background-position: top;
            background-size: var(--pip-width) var(--pip-height);
            background-repeat: repeat-y;

            display: inline-block;
            width: var(--pip-width);
            height: 4em;
        }
        .pipstack-container {
            width: 3.5rem;
            gap: 0.5rem;
        }
        .pipstack {
            /*width: 3.5em; /* 2n-1 times pip-width */
            /* gap: 0.5em; */
            justify-content: space-between;
        }
        .pip {
            background-color: var(--color-hud);
            display: inline-block;
            width: 0.5rem;
            height: 0.5rem;
            opacity: 1.0;
        }
        #pip-title{
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translate(-50%,-50%);
            font-size: 0.9em;
        }
        #pip-distance {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translate(-50%,-50%);
            font-size: 1.5em;
        }
        #pip-widget {
            position: absolute;
            top: 85%;
            left: 50%;
            transform: translate(-50%,-50%);
            gap: 1em;
        }
        #pip-reset {
            border-bottom: 1px solid var(--color-hud);
            display: inline-block;
            position: absolute;
            padding: 0.25em 2ch;
            top: 90%;
            left: 50%;
            transform: translate(-50%,-50%);
        }
        #visualizer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%,-50%);
        }

        /* CONSOLE WIDGET (TOP-LEFT) */
        #log {
            position: absolute;
            top: 1vmax;
            left: 1vmax;
        }

        /* CONTROLS WIDGET (BOTTOM-LEFT) */
        #controls-widget {
            filter: var(--filter-glow-hud);
            position: absolute;
            bottom: 2em;
            left: 2em;
            gap: 0.5em;
        }
        .controls-key, .controls-spacebar {
            cursor: pointer;
            border: 2px solid var(--color-hud);
            border-radius: 0.5em;
            display: inline-block;
            font-size: 1.5em;
            text-align: center;
            align-self: center;
        }
        .controls-key {
            width: 2em;
            height: 2em;
        }
        .controls-spacebar {
            width: 5em;
            height: 2em;
        }


        @keyframes spin {
            0% { transform: translate(50%,50%) rotate(0deg); }
            100% { transform: translate(50%,50%) rotate(360deg); }
        }

    </style>
</head>
<body>

    <!-- <div id='background'></div> -->
    <div id='log' class='bordered-widget'>
        <div class='frame-top'></div>
        <div class='frame-bot'></div>
    </div>
    <div id='lock-box'>
        <div id='pip-title'>DISTANCE</div>
        <div id='pip-distance'>5.505</div>
        <svg id='visualizer' viewBox='0 0 100 100' preserveAspectRatio='none' width='250' height='250'>
            <g id='visualizer-svg' fill='none' stroke='#fca558' stroke-width='1' transform='translate(50 50)'>
                <circle cx='0' cy='0' r='48'/>
            </g>
        </svg>
        <div id='pip-widget' class='flex-row'>
            <div id='pipstack-0' class='flex-col pipstack-container' style='position:relative;'>
                <div class='flex-row pipstack'>
                    <div id='pip-0-0' class='pip'></div>
                    <div id='pip-0-1' class='pip'></div>
                    <div id='pip-0-2' class='pip'></div>
                    <div id='pip-0-3' class='pip'></div>
                </div>
                <div id='pip-label-0' style='text-align:center;'>L</div>
            </div>
            <div id='pipstack-1' class='flex-col pipstack-container' style='position:relative;top:-2em;'>
                <div class='flex-row pipstack'>
                    <div id='pip-1-0' class='pip'></div>
                    <div id='pip-1-1' class='pip'></div>
                    <div id='pip-1-2' class='pip'></div>
                    <div id='pip-1-3' class='pip'></div>
                </div>
                <div id='pip-label-1' style='text-align:center;'>U</div>
            </div>
            <div id='pipstack-2' class='flex-col pipstack-container' style='position:relative;'>
                <div class='flex-row pipstack'>
                    <div id='pip-2-0' class='pip'></div>
                    <div id='pip-2-1' class='pip'></div>
                    <div id='pip-2-2' class='pip'></div>
                    <div id='pip-2-3' class='pip' style='opacity:0.05;'></div>
                </div>
                <div id='pip-label-2' style='text-align:center;'>R</div>
            </div>
        </div>
        <div id='pip-reset'>RESET</div>
    </div>

    <div id='controls-widget' class='flex-col'> <!-- element is only 50% as bright if not positioned, for some reason -->
        <div id='controls-up' class='controls-key' onclick='tryGuess(2)'>W</div>
        <div class='flex-row' style='justify-content:center; gap:0.5em;'>
            <div id='controls-left' class='controls-key' onclick='tryGuess(0)'>A</div>
            <div id='controls-down' class='controls-key' onclick='tryGuess(3)'>S</div>
            <div id='controls-right' class='controls-key' onclick='tryGuess(1)'>D</div>
        </div>
    </div>

    <script type='text/javascript'>

        //// DOM ////
        const msgLog = document.getElementById('log');
        const lockBox = document.getElementById('lock-box');
        const svg = document.getElementById('visualizer-svg');
        const pipTitleTop = document.getElementById('pip-title');
        const pipTitleBot = document.getElementById('pip-distance');
        const pipElems = [
            [document.getElementById('pip-0-0'),document.getElementById('pip-0-1'),document.getElementById('pip-0-2'),document.getElementById('pip-0-3')], // L
            [document.getElementById('pip-1-0'),document.getElementById('pip-1-1'),document.getElementById('pip-1-2'),document.getElementById('pip-1-3')], // U
            [document.getElementById('pip-2-0'),document.getElementById('pip-2-1'),document.getElementById('pip-2-2'),document.getElementById('pip-2-3')]  // R
        ];
        const pipLabels = [document.getElementById('pip-label-0'),document.getElementById('pip-label-1'),document.getElementById('pip-label-2')];
        // controls vis
        const controlsUp = document.getElementById('controls-up');
        const controlsLeft = document.getElementById('controls-left');
        const controlsDown = document.getElementById('controls-down');
        const controlsRight = document.getElementById('controls-right');

        const MSG_INSTRUCTIONS = [
            'CONTROLS',
            '',
            '[WASD] or arrow keys to triangulate',
            '[S] or [DownArrow] to return to starting position',
            '',
            '[R] for new pip-lock with current settings',
            '[`] to toggle alternate UI',
            '',
            '(All combos reachable in 7 moves or less. Good luck!)'

        ].join('\n');
        msgLog.innerHTML = MSG_INSTRUCTIONS + `<div class = 'frame-top'></div><div class = 'frame-bot'></div>`;

        const CSSVars = {
            get : (k) => getComputedStyle(document.documentElement).getPropertyValue(k),
            set : (k,v) => document.documentElement.style.setProperty(k,v)
        };
        const randI = (min,max) => Math.floor(Math.random() * (max - min + 1)) + min;
        const randInt = (min,max) => {
            if (min > max) [min,max] = [max,min];
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function svgStr (l = 100, offsetY = 1) {
            // sidelengths of subtriangles
            const h = l / 2;
            const r = h * Math.sqrt(3);
            // triangular interpolation w/ barycentric coords (https://codeplea.com/triangular-interpolation)
            const w = controller.gamestate.map(p => p/6); // weights are pips as percent-of-total (6 total pips) s.t. w0+w1+w2=1
            const v = [{x:-r,y:h+offsetY}, {x:0,y:-l+offsetY}, {x:r,y:h+offsetY}]; // vertices of triangle
            const px = w[0]*v[0].x + w[1]*v[1].x + w[2]*v[2].x;
            const py = w[0]*v[0].y + w[1]*v[1].y + w[2]*v[2].y;
            // percent-of-max distance factor: distFromSolution / maxDistPossible
            const distFac = 1 - (controller.distance / 5.5); // max observed was 5.339; build a solver for this eventually
            // console.log(`dist fac ${distFac}`);

            // triangular frame
            const frameStr = `<polygon points='${-r},${h+offsetY} 0,${-l+offsetY} ${r},${h+offsetY}'/>`; // offset by linewidth so tip of tri doesn't go outside canvas
            // influence tracers
            const interpolationStr = `<path d='`
                + `M ${v[0].x} ${v[0].y} L ${px} ${py} `
                + `M ${v[1].x} ${v[1].y} L ${px} ${py} `
                + `M ${v[2].x} ${v[2].y} L ${px} ${py}`
            + `' stroke-width='0.5' opacity='${0.5}'/>`;
            // current location (circle)
            const locStr = ``; // `<circle fill='#fca558' cx='${px}' cy='${py}' r='1.0' opacity='${distFac}'/>`;
            
            return frameStr + interpolationStr + locStr;
        }
        // const SVG_FRAME = svgStr(50);
        // svg.innerHTML = SVG_FRAME;

        function updateSVG () {
            svg.innerHTML = svgStr(50);
        }

        function updatePips () {
            if (controller.succeeded) {
                pipTitleTop.innerHTML = '[R] for new lock';
                pipTitleBot.innerHTML = 'VICTORY';
            } else {
                pipTitleTop.innerHTML = 'SWEET SPOT DISTANCE';
                pipTitleBot.innerHTML = controller.distance.toFixed(3);
            }
            for (let pipstack = 0; pipstack < 3; pipstack++) {
                // pip visualization
                for (let pip = 0; pip < 4; pip++) {
                    const e = pipElems[pipstack][pip];
                    if (controller.gamestate[pipstack] == pip+0.5) e.style.opacity = '0.3'; // half-pip; equivalent to pip+1-0.5 for zero-indexing
                    else if (controller.gamestate[pipstack] >= pip+1) e.style.opacity = '1.0'; // pip+1 to account for zero-indexing
                    else e.style.opacity = '0.05';
                }
                // pip label
                pipLabels[pipstack].innerHTML = controller.gamestate[pipstack];
            }
        }

        let dbg_useAltSpacing = false;
        function toggleAltSpacing () {
            dbg_useAltSpacing = !dbg_useAltSpacing;

            document.getElementById('visualizer').style.top = (dbg_useAltSpacing) ? '62%' : '50%';
            document.getElementById('pipstack-0').style.top = (dbg_useAltSpacing) ? '-1em' : '0';
            document.getElementById('pipstack-1').style.top = (dbg_useAltSpacing) ? '-16.5em' : '-2em';
            document.getElementById('pipstack-2').style.top = (dbg_useAltSpacing) ? '-1em' : '0';
            
            document.getElementById('pipstack-0').style.left = (dbg_useAltSpacing) ? '-3em' : '0';
            document.getElementById('pipstack-2').style.left = (dbg_useAltSpacing) ? '3em' : '0';
        }
        
        //
        
        // const REGEX_VALID_GAMESTATE = /^([0-4](?:\.5)?)-([0-4](?:\.5)?)-([0-4](?:\.5)?)$/;
        function isValidGamestate (gamestate) {
            const [l,u,r] = gamestate.map(x => parseFloat(x));
            if (l+u+r != 6) return false; // always 6 pips total
            if (l > 4 || u > 4 || r > 4) return false; // pip-stack has between 0 and 4 pips
            if (l < 0 || u < 0 || r < 0) return false;
            if ((l*10)%5 != 0 || (u*10)%5 != 0 || (r*10)%5 != 0) return false; // pips are all increments of .5
            return true;
        }
        // console.log( isValidGamestate('2-2-2') ); // true ([init])
        // console.log( isValidGamestate('4-2-0') ); // true (LLUL)
        // console.log( isValidGamestate('0-3-3') ); // true (RURU)
        // console.log( isValidGamestate('3-1.5-1.5') ); // true (L)
        // console.log( isValidGamestate('5-1-0') ); // false, pipstack too tall
        // console.log( isValidGamestate('-2-4-4') ); // false, negative pipstack / blank pip
        // console.log( isValidGamestate('3-2-2') ); // false, too many pips
        // console.log( isValidGamestate('3-2') ); // false, too few pipstacks
        // console.log( isValidGamestate('3-1.75-1.25') ); // false, bad increment

        
        const MOVE_DIR_RESET = 0;
        const MOVE_DIR_LEFT = 1;
        const MOVE_DIR_UP = 2;
        const MOVE_DIR_RIGHT = 3;
        function newGamestate (start,dir) {
            const [l,u,r] = start.map(x => parseFloat(x));
            // console.log(l,u,r);
            if (dir == MOVE_DIR_LEFT) {
                if (l == 4) return [l,u,r]; // left corner full (420,402,411) can't draw more pips
                if (l == 3.5) { // draw single half-pip from lowest non-zero pipstack
                    if (u == 0) return [l+0.5,u,r-0.5];
                    if (r == 0) return [l+0.5,u-0.5,r];
                    return (u < r) ? [l+0.5,u-0.5,r] : [l+0.5,u,r-0.5];
                } else { // draw two half-pips, one from each pipstack if possible
                    if (u == 0) return [l+1,u,r-1]; // if up is empty, pull both half-pips from right
                    if (r == 0) return [l+1,u-1,r]; // if right is empty, pull both half-pips from up
                    return [l+1,u-0.5,r-0.5]; // pull half-pips normally
                }
            } else if (dir == MOVE_DIR_UP) {
                if (u == 4) return [l,u,r]; // upper corner (240,042,141) can't move up
                if (u == 3.5) { // draw single half-pip from lowest non-zero pipstack
                    if (l == 0) return [l,u+0.5,r-0.5];
                    if (r == 0) return [l-0.5,u+0.5,r];
                    return (l < r) ? [l-0.5,u+0.5,r] : [l,u+0.5,r-0.5];
                } else { // draw two half-pips, one from each pipstack if possible
                    if (l == 0) return [l,u+1,r-1]; // if left is empty, pull both half-pips from right
                    if (r == 0) return [l-1,u+1,r]; // if right is empty, pull both half-pips from left
                    return [l-0.5,u+1,r-0.5]; // pull half-pips normally
                }
            } else if (dir == MOVE_DIR_RIGHT) {
                if (r == 4) return [l,u,r]; // right corner (204,024,114) can't move right
                if (r == 3.5) { // draw single half-pip from lowest non-zero pipstack
                    if (l == 0) return [l,u-0.5,r+0.5];
                    if (u == 0) return [l-0.5,u,r+0.5];
                    return (l < u) ? [l-0.5,u,r+0.5] : [l,u-0.5,r+0.5];
                } else { // draw two half-pips, one from each pipstack if possible
                    if (l == 0) return [l,u-1,r+1]; // if left is empty, pull both half-pips from up
                    if (u == 0) return [l-1,u,r+1]; // if up is empty, pull both half-pips from left
                    return [l-0.5,u-0.5,r+1]; // pull half-pips normally
                }
            } else if (dir == MOVE_DIR_RESET) {
                return [2,2,2];
            } else {
                console.warn(`ERR Invalid move direction "${dir}"`);
            }
        }
        // console.log( newGamestate([2,2,2],MOVE_DIR_LEFT) );
        // console.log( newGamestate([2,2,2],MOVE_DIR_UP) );
        // console.log( newGamestate([2,2,2],MOVE_DIR_RIGHT) );
        // console.log( newGamestate([4,2,0],MOVE_DIR_LEFT) );

        

        class PiplockSolver {
            constructor () {
                this.initialState = '2-2-2';
                this.gamestates = [];
                this.gamestateData = {};
            }
            map () {
                const MOVE_CHARS = ['-','L','U','R']; // reset,left,up,right
                function equivalentStates (s0,s1) {
                    const [state0,len0,path0] = s0;
                    const [l0,u0,r0] = state0;
                    const [state1,len1,path1] = s1;
                    const [l1,u1,r1] = state1;
                    return (l0 != l1 || u0 != u1 || r0 != r1);
                }
                // BFS
                let overflowProt = 1000;
                let queue = [ [[2,2,2], 0, '', '2-2-2'] ]; // [gamestate, pathlen, inputs, path]
                this.gamestateData['2-2-2'] = [[2,2,2],0,'','2-2-2'];
                while (queue.length > 0 && overflowProt > 0) {
                    overflowProt--;
                    const [currState,currLen,currInputs,currPath] = queue.shift();
                    for (let dir of [MOVE_DIR_LEFT,MOVE_DIR_UP,MOVE_DIR_RIGHT]) {
                        const nextState = newGamestate(currState,dir);
                        const nextLen = currLen + 1;
                        const nextInputs = currInputs + MOVE_CHARS[dir];
                        const nextStr = nextState.join('-');
                        const nextPath = currPath + '=>' + nextStr;
                        if (!this.gamestateData[nextStr]) { // if unvisited, auto pass
                            if (!isValidGamestate(nextState)) {
                                console.error(`ERR ${nextStr} by ${MOVE_CHARS[dir]} from ${nextPath} (len ${nextLen})`);
                                continue;
                            } else {
                                console.log(`FIRST ${nextStr} by ${MOVE_CHARS[dir]} from ${nextPath} (len ${nextLen})`);
                            }
                            this.gamestateData[nextStr] = [nextState,nextLen,nextInputs,nextPath];
                            queue.push([nextState,nextLen,nextInputs,nextPath]);
                        } else if (nextLen < this.gamestateData[nextStr][1]) { // if shorter than previous optimum, replace it
                            console.debug(`REPLACE ${nextStr} by ${MOVE_CHARS[dir]} from ${this.gamestateData[nextStr][2]} to ${nextPath} (len ${this.gamestateData[nextStr][1]} to ${nextLen})`);
                            this.gamestateData[nextStr] = [nextState,nextLen,nextInputs,nextPath];
                            queue.push([nextState,nextLen,nextInputs,nextPath]);
                        } else {
                            console.warn(`FAIL ${nextStr} by ${MOVE_CHARS[dir]} from ${nextPath} (len ${nextLen})`);
                        }
                    }
                }
                if (overflowProt <= 0) {
                    console.error(`WARN Triggered loop overflow protection; loop may be infinite.`);
                    console.log(queue);
                } else {
                    this.gamestates = Object.keys(this.gamestateData);
                }
                console.log(this.gamestateData);
            }
            minMovesTo (end) {
                return this.gamestateData[end][1]; // [gamestate, pathlen, inputs, path]
            }
            shortestPathTo (end) {
                return this.gamestateData[end][2]; // [gamestate, pathlen, inputs, path]
            }
        }
        class PiplockController {
            constructor () {
                this.moves = 0;
                this.combo = [];
                this.gamestate = [2,2,2];
                this.reset();
            }
            get distance () {
                const dx = this.gamestate[0]-this.combo[0];
                const dy = this.gamestate[1]-this.combo[1];
                const dz = this.gamestate[2]-this.combo[2];
                return Math.sqrt(dx*dx + dy*dy + dz*dz);
                //// current max observed dist (we should really build a solver for this) ////
                // 2.5,0,3.5 -> 2,4,0
                // delta = 0.5 + 4 + 3.5
                // dist = Math.sqrt(0.5*0.5 + 4*4 + 3.5*3.5) = 5.3
            }
            get succeeded () { return this.combo[0]==this.gamestate[0] && this.combo[1]==this.gamestate[1] && this.combo[2]==this.gamestate[2]; }
            get minMoves () { return solver.minMovesTo(this.combo.join('-')); }
            get difficulty () { return (this.minMoves <= 4) ? 'Easy' : 'Hard'; }
            reset (minPathLen = 3, maxPathLen = 7) {
                let gamestate = '2-2-2';
                while (solver.gamestateData[gamestate][1] < minPathLen || solver.gamestateData[gamestate][1] > maxPathLen) { // [gamestate, pathlen, inputs, path]
                    gamestate = solver.gamestates[randInt(0,solver.gamestates.length-1)];
                }
                this.combo = gamestate.split('-');
                this.gamestate = [2,2,2];
                console.log(`Lock reset. Solvable in ${this.minMoves} moves.`);
            }
            try (dir) {
                if (this.succeeded) {
                    console.log('Lock already solved. Generate a new lock to play again.');
                } else {
                    this.gamestate = newGamestate(this.gamestate,dir);
                    this.moves++;
                    if (this.succeeded) {
                        console.log(`Victory! You solved the lock in ${this.moves} moves.`);
                    } else {
                        console.log(`[${this.gamestate}] - distance to solution is ${this.distance}`);
                    }
                }
                return this.gamestate;
            }
        }

        let solver = new PiplockSolver();
        solver.map();
        let controller = new PiplockController();


        let dbgToggle = true;
        window.addEventListener('keydown', e => {
            // console.log(e.key);
            switch (e.key) {
            // controls
            case 'a':
            case 'ArrowLeft':  controller.try(MOVE_DIR_LEFT);  updatePips(); updateSVG(); controlsLeft.style.borderWidth = '4px'; break;
            case 'd':
            case 'ArrowRight': controller.try(MOVE_DIR_RIGHT); updatePips(); updateSVG(); controlsRight.style.borderWidth = '4px'; break;
            case 'w':
            case 'ArrowUp':    controller.try(MOVE_DIR_UP);    updatePips(); updateSVG(); controlsUp.style.borderWidth = '4px'; break;
            case 's':
            case 'ArrowDown':  controller.try(MOVE_DIR_RESET); updatePips(); updateSVG(); controlsDown.style.borderWidth = '4px'; break;
            case 'r': controller.reset(); updatePips(); updateSVG(); break;
            
            // debug
            case '`':
                console.log('DEV KEY');
                toggleAltSpacing();
                break;
            }
        });
        window.addEventListener('keyup', e => {
            switch (e.key) {
            // controls
            case 'a':
            case 'ArrowLeft':  controlsLeft.style.borderWidth = '2px'; break;
            case 'd':
            case 'ArrowRight': controlsRight.style.borderWidth = '2px'; break;
            case 'w':
            case 'ArrowUp':    controlsUp.style.borderWidth = '2px'; break;
            case 's':
            case 'ArrowDown':  controlsDown.style.borderWidth = '2px'; break;
            }
        });

        // init
        console.log(MSG_INSTRUCTIONS);
        // controller.reset();
        updatePips();
        updateSVG();
        // pipTitleTop.innerHTML = `New lock. Solvable in ${controller.minMoves} moves.`;

    </script>

</body>